package com.prime.prime_app.service;

import com.prime.prime_app.entities.User;
import com.prime.prime_app.entities.WorkLog;
import com.prime.prime_app.entities.Client;
import com.prime.prime_app.entities.PolicyStatus;
import com.prime.prime_app.dto.agent.AttendanceRequest;
import com.prime.prime_app.dto.agent.AttendanceResponse;
import com.prime.prime_app.dto.agent.ClientEntryRequest;
import com.prime.prime_app.dto.agent.ClientEntryResponse;
import com.prime.prime_app.dto.agent.PerformanceReportResponse;
import com.prime.prime_app.exception.InvalidOperationException;
import com.prime.prime_app.exception.ResourceNotFoundException;
import com.prime.prime_app.exception.ServiceException;
import com.prime.prime_app.exception.ValidationException;
import com.prime.prime_app.repository.ClientRepository;
import com.prime.prime_app.repository.ManagerAssignedAgentRepository;
import com.prime.prime_app.repository.UserRepository;
import com.prime.prime_app.repository.WorkLogRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.temporal.TemporalAdjusters;
import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class AgentService {
    private final UserRepository userRepository;
    private final WorkLogRepository workLogRepository;
    private final ClientRepository clientRepository;
    private final ManagerAssignedAgentRepository managerAssignedAgentRepository;
    private final AuthService authService;

    public boolean isAgentAssignedToManager(User agent) {
        return managerAssignedAgentRepository.findByAgent(agent).size() > 0;
    }

    @Transactional
    public AttendanceResponse submitAttendance(User agent, AttendanceRequest request) {
        if (!isAgentAssignedToManager(agent)) {
            throw new IllegalStateException("Agent is not assigned to any manager");
        }

        LocalDate today = LocalDate.now();
        if (workLogRepository.findByAgentAndDate(agent, today).isPresent()) {
            throw new IllegalStateException("Attendance already submitted for today");
        }

        LocalTime now = LocalTime.now();
        if (now.isBefore(LocalTime.of(6, 0)) || now.isAfter(LocalTime.of(9, 0))) {
            throw new IllegalStateException("Attendance can only be submitted between 6:00 AM and 9:00 AM");
        }

        WorkLog workLog = WorkLog.builder()
                .agent(agent)
                .date(today)
                .status(WorkLog.WorkStatus.WORKED)
                .clientsServed(0)
                .location(request.getLocation())
                .sector(request.getSector())
                .checkInTime(LocalDateTime.now())
                .autoGenerated(false)
                .build();

        workLogRepository.save(workLog);

        return AttendanceResponse.builder()
                .status("Attendance submitted successfully")
                .redirectTo("/client-entry")
                .build();
    }

    @Transactional
    public ClientEntryResponse logClientInteraction(User agent, ClientEntryRequest request) {
        try {
            if (agent == null || !agent.isEnabled()) {
                throw new InvalidOperationException("Agent account is not active");
            }

            if (!isAgentAssignedToManager(agent)) {
                throw new InvalidOperationException("Agent is not assigned to any manager");
            }

            LocalDate today = LocalDate.now();
            Optional<WorkLog> workLogOpt = workLogRepository.findByAgentAndDate(agent, today);

            WorkLog workLog;
            if (workLogOpt.isEmpty()) {
                log.info("No work log found for agent {}, creating one automatically", agent.getId());
                workLog = WorkLog.builder()
                        .agent(agent)
                        .date(today)
                        .status(WorkLog.WorkStatus.WORKED)
                        .clientsServed(0)
                        .location(request.getLocationOfClient())
                        .sector("Auto-created")
                        .checkInTime(LocalDateTime.now())
                        .autoGenerated(true)
                        .build();
                workLog = workLogRepository.save(workLog);
                log.info("Created new work log for agent {} with ID {}", agent.getId(), workLog.getId());
            } else {
                workLog = workLogOpt.get();
            }

            LocalDate dateOfBirth = request.getDate_of_birth() != null ?
                    LocalDate.parse(request.getDate_of_birth()) :
                    LocalDate.now().minusYears(18);

            String[] nameParts = request.getName().split(" ", 2);
            String firstName = nameParts[0];
            String lastName = nameParts.length > 1 ? nameParts[1] : "";

            LocalDate policyEnd = today.plusYears(1);

            Client client = Client.builder()
                    .agent(agent)
                    .name(request.getName())
                    .firstName(firstName)
                    .lastName(lastName)
                    .nationalId(request.getNationalId())
                    .phoneNumber(request.getPhone())
                    .insuranceType(Client.InsuranceType.valueOf(request.getInsuranceType()))
                    .location(request.getLocationOfClient())
                    .dateOfBirth(dateOfBirth)
                    .policyStatus(PolicyStatus.PENDING)
                    .policyStartDate(today)
                    .policyEndDate(policyEnd)
                    .premiumAmount(0.0)
                    .timeOfInteraction(LocalDateTime.now())
                    .build();

            client = clientRepository.save(client);

            workLog.setClientsServed(workLog.getClientsServed() + 1);
            workLogRepository.save(workLog);

            log.info("Successfully logged client interaction for agent {} with client {}", agent.getId(), client.getId());

            return ClientEntryResponse.builder()
                    .status("SUCCESS")
                    .timeOfInteraction(client.getTimeOfInteraction().toString())
                    .build();

        } catch (ResourceNotFoundException | InvalidOperationException e) {
            log.warn("Validation error in client interaction logging: {}", e.getMessage());
            throw e;
        } catch (IllegalArgumentException e) {
            log.error("Invalid insurance type provided: {}", request.getInsuranceType());
            throw new ValidationException("Invalid insurance type. Must be one of: " +
                    String.join(", ", java.util.Arrays.stream(Client.InsuranceType.values())
                            .map(Enum::name)
                            .collect(java.util.stream.Collectors.toList())));
        } catch (Exception e) {
            log.error("Unexpected error while logging client interaction: {}", e.getMessage());
            throw new ServiceException("Failed to log client interaction. Please try again later.");
        }
    }

    @Transactional(readOnly = true)
    public PerformanceReportResponse getPerformanceReport(User agent, String period) {
        // Validate period (already done in controller, but adding here for robustness)
        period = period.toUpperCase();
        if (!Arrays.asList("DAILY", "WEEKLY", "MONTHLY").contains(period)) {
            throw new IllegalArgumentException("Invalid period specified");
        }

        LocalDate startDate;
        LocalDate endDate = LocalDate.now();

        switch (period) {
            case "DAILY":
                startDate = endDate;
                break;
            case "WEEKLY":
                startDate = endDate.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));
                break;
            case "MONTHLY":
                startDate = endDate.withDayOfMonth(1);
                break;
            default:
                throw new IllegalArgumentException("Invalid period specified");
        }

        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(23, 59, 59);
        Long totalClientsEngaged = clientRepository.countByAgentAndTimeRange(agent, startDateTime, endDateTime);

        List<String> sectorsWorkedIn = workLogRepository.findSectorsByAgentAndDateRange(agent, startDate, endDate);

        Long daysWorked = workLogRepository.countWorkDaysByAgentAndDateRange(agent, startDate, endDate);

        Map<String, Integer> dailyClientsCount = getDailyClientsCount(agent, startDate, endDate);
        Map<String, List<String>> dailySectors = getDailySectors(agent, startDate, endDate);
        Map<String, String> workStatus = getWorkStatus(agent, startDate, endDate);

        return PerformanceReportResponse.builder()
                .total_clients_engaged(totalClientsEngaged != null ? totalClientsEngaged.intValue() : 0)
                .sectors_worked_in(sectorsWorkedIn)
                .days_worked(daysWorked != null ? daysWorked.intValue() : 0)
                .daily_clients_count(dailyClientsCount)
                .daily_sectors(dailySectors)
                .work_status(workStatus)
                .build();
    }

    private Map<String, Integer> getDailyClientsCount(User agent, LocalDate startDate, LocalDate endDate) {
        Map<String, Integer> result = new HashMap<>();

        for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {
            String dayName = date.getDayOfWeek().toString().charAt(0) +
                    date.getDayOfWeek().toString().substring(1).toLowerCase();

            LocalDateTime dateStart = date.atStartOfDay();
            LocalDateTime dateEnd = date.atTime(23, 59, 59);
            Long count = clientRepository.countByAgentAndTimeRange(agent, dateStart, dateEnd);

            result.put(dayName, count != null ? count.intValue() : 0);
        }

        return result;
    }

    private Map<String, List<String>> getDailySectors(User agent, LocalDate startDate, LocalDate endDate) {
        Map<String, List<String>> result = new HashMap<>();

        // Fill in each day from start to end date
        for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {
            String dayName = date.getDayOfWeek().toString().charAt(0) +
                    date.getDayOfWeek().toString().substring(1).toLowerCase();

            // Get sectors from client data (insurance types)
            LocalDateTime dateStart = date.atStartOfDay();
            LocalDateTime dateEnd = date.atTime(23, 59, 59);
            List<String> sectors = clientRepository.findInsuranceTypesByAgentAndTimeRange(agent, dateStart, dateEnd);

            // If no sectors from client data, fall back to work log
            if (sectors == null || sectors.isEmpty()) {
                sectors = workLogRepository.findByAgentAndDate(agent, date)
                        .map(log -> log.getSector())
                        .map(List::of)
                        .orElse(new ArrayList<>());
            }

            result.put(dayName, sectors != null ? sectors : new ArrayList<>());
        }

        return result;
    }

    private Map<String, String> getWorkStatus(User agent, LocalDate startDate, LocalDate endDate) {
        Map<String, String> result = new HashMap<>();

        for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {
            String dayName = date.getDayOfWeek().toString().charAt(0) +
                    date.getDayOfWeek().toString().substring(1).toLowerCase();

            boolean worked = workLogRepository.findByAgentAndDate(agent, date)
                    .map(log -> log.getStatus() == WorkLog.WorkStatus.WORKED)
                    .orElse(false);

            LocalDateTime dateStart = date.atStartOfDay();
            LocalDateTime dateEnd = date.atTime(23, 59, 59);
            Long clientCount = clientRepository.countByAgentAndTimeRange(agent, dateStart, dateEnd);

            String status;
            if (!worked) {
                status = "No work";
            } else if (clientCount != null && clientCount > 0) {
                status = "Worked";
            } else {
                status = "Worked but no clients";
            }

            result.put(dayName, status);
        }

        return result;
    }
}